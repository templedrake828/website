---
title: Using Python to Solve the Queens Problem
author: Temple Davies
date: '2019-12-15'
slug: blog-post
categories: []
tags: []
description: ''
---

The solution to the Queens problem describes a chess board in which no queen can capture another. Given a n x n chessboard, this program prints all the unique solutions to the Queens problem as well as the number of unique solutions.

```{r setup, include=FALSE}}
library(reticulate)
knitr::knit_engines$set(python = reticulate::eng_python)
```

```{python}
class Queens (object):
  # initialize the board
    def __init__ (self, n = 8):
        self.board = []
        self.n = n
        self.sum = 0
        for i in range (self.n):
            row = []
            for j in range (self.n):
                row.append ('*')
            self.board.append (row)

  # print the board
    def print_board (self):
        for i in range (self.n):
            for j in range (self.n):
                print (self.board[i][j], end = ' ')
            print ()

  # check if no queen captures another
    def is_valid (self, row, col):
        for i in range (self.n):
            if (self.board[row][i] == 'Q' or self.board[i][col] == 'Q'):
                return False
        for i in range (self.n):
            for j in range (self.n):
                row_diff = abs (row - i)
                col_diff = abs (col - j)
                if (row_diff == col_diff) and (self.board[i][j] == 'Q'):
                    return False
        return True

  # checks final chess board to see if it should be printed out
    def check(self):
        count = 0
        for row in self.board:
            numQueens = row.count('Q')
            count += numQueens
        if (count == self.n):
            return True
        return False
    
  # do a recursive backtracking solution
    def recursive_solve (self, col):
        if (col == self.n):
            if (self.check() == True):
                self.print_board()
                print()
                self.sum += 1
        else:
            for i in range (self.n):
                if (self.is_valid(i, col)):
                    self.board[i][col] = 'Q'
                    if (self.recursive_solve (col + 1)):
                        return True
                    self.board[i][col] = '*'
            return False
        
  # if the problem has a solution print the board
    def solve (self):
        for i in range (self.n):
            self.recursive_solve(i)
```

```{python}
game = Queens()
game.n = int(input("Enter the size of the board: "))
print()
```

```{python}
 while (game.n < 1) or (game.n > 8):
        print("Please enter a number between 1 and 8.")
        game.n = int(input("Enter the size of the board: "))
      
    if (game.n >=1) and (game.n <= 8):
        game.solve()
        count = int(game.sum)
        n = game.n
        if (count == 0):
            print("\nThere are 0 solutions to a %s x %s board." % (n,n))
        elif count == 1:
            print("\nThere is 1 solution to a %s x %s board." % (n,n))
        else:
            print("\nThere are %s solutions for a %s x %s board." % (count, n, n))
```
  
  
